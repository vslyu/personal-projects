
#### [最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)
#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

`请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。`

**思路**： 滑动窗口

```cpp
    int lengthOfLongestSubstring(string s) {
        if(s.length() <= 1) {
            return s.length();
        }
        unordered_map<char, int> m;
        int ans = 0;
        int start = 0;
        int end = 0;
        while(end < s.length()) {
            while(end < s.length() && m.find(s[end]) == m.end()) {
                m[s[end++]] = 1;
            }
            ans = max(ans, end - start);
            if (end == s.length()) {
                break;
            }
            while(start < end) {
                m.erase(s[start]);
                if(s[start] == s[end]) {
                    break;
                }
                ++start;
            }
            ++start;
        }
        return ans;
    }
```

#### [串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

`给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。`

```cpp
for(int start  = 0; start + words.size() * len <= s.length(); ++start) {
    unordered_map<string, int> m1 = m;
    for(int end = start; 
        end + len <= s.length() && 
        end + len <= start + words.size() * len; end += len) {
```

#### [最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

`给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。`

```cpp
    string minWindow(string s, string t) {
        if(s.length() == 0 || t.length() == 0) {
            return "";
        }
        unordered_map<char, int> target;
        for(char c : t) {
            target[c]++;
        }
        int ans = INT_MAX;
        string ret = "";
        int start = 0;
        int end = 0;
        int count = 0;
        unordered_map<char, int> m;
        while(end < s.length()) {
            while(end < s.length() && count != target.size()) {
                if (target.find(s[end]) == target.end()) {
                    ++end;
                    continue;
                }
                m[s[end]]++; 
                if(m[s[end]] == target[s[end]]) {
                    ++count;
                }
                ++end;
            }
            if(count != target.size()) {
                break;
            }
            while(start < end) {
                if(target.find(s[start]) == target.end()) {
                    ++start;
                    continue;
                }
                if(ans > end - start) {
                    ans = end - start;
                    ret = s.substr(start, end - start);
                }
                --m[s[start]];
                if(m[s[start]] < target[s[start]]) {
                    --count;
                    break;
                }
                ++start;
            }
            ++start;
        }
        return ret;
    }
```

#### [重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)

`编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。`

```cpp
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> ans;
        if(s.length() < 10) {
            return ans;
        }
        unordered_map<string, int> m;
        int start = 0;
        while(start + 10 <= s.length()) {
            string cur = s.substr(start, 10);
            if(m.find(cur)!= m.end()) {
                if (m[cur] == 0) {
                    ans.push_back(cur);
                    m[cur] = 1;
                }
            } else {
                m[cur] = 0;
            }
            ++start;
        }
        return ans;
    }
```

#### [存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

`给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。`

```cpp
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> m;
        for(int i = 0; i < nums.size(); ++i) {
            if(m.find(nums[i]) != m.end()) {
                return true;
            }
            m[nums[i]]++;

            if(m.size() > k) {
                m[nums[i - k]]--;
                if(m[nums[i - k]] == 0) {
                    m.erase(nums[i - k]);
                }
            }
        }
        return false;
    }
```

#### [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

`给定一个非空的整数数组，返回其中出现频率前 k 高的元素。`

```cpp
    vector<int> topKFrequent(vector<int>& nums, int k) {  
        unordered_map<int, int> freq;
        auto cmp1 = [&freq](int left, int right) {
            return freq[left] > freq[right];
        };
        priority_queue<int, vector<int>, decltype(cmp1)> topk(cmp1);
        vector<int> ans;
        for(int num : nums) {
            freq[num]++; 
        }
        for(auto kv : freq) {
            if(topk.size() < k) {
                topk.push(kv.first);
            } else if(freq[topk.top()] < kv.second) {
                topk.push(kv.first);
                topk.pop();
            }
        }
        while(!topk.empty()) {
            ans.push_back(topk.top());
            topk.pop();
        }
        return ans;
    }
```

#### [常数时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

```
哈希表提供常数时间的插入和删除
getRandom 的思想是选择一个随机索引，然后使用该索引返回一个元素。解决的方法是用一个列表存储值，并在该列表中实现常数时间的 getRandom。
删除任意索引元素需要线性时间，这里的解决方案是总是删除最后一个元素。将要删除元素和最后一个元素交换，然后删除最后一个元素。
```

#### [O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

哈希表的元素为set
