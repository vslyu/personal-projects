
#### [最大数](https://leetcode-cn.com/problems/largest-number/)

`给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。`

**思路**： 设计一种cmp函数

```cpp
    string int2str(int a) {
        stringstream ss;
        ss << a;
        string s;
        ss >> s;
        return s;
        
    }
    static bool cmp(string& a, string& b) {
        return a + b > b + a;
    }
    string largestNumber(vector<int>& nums) {
        if(nums.size()==0){
            return "";
        }
        vector<string> vec;
        for(int num : nums) {
            vec.push_back(int2str(num));
        }
        sort(vec.begin(), vec.end(), cmp);
        if(vec[0] == "0") {
            return "0";
        }
        string ans;
        for(int i = 0; i < vec.size(); ++i) {
            ans += vec[i];
        }
        return ans;
    }
```

#### [颜色分类](https://leetcode-cn.com/problems/sort-colors/)

`给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。`

**思路**： 类似于快排的partition

```cpp
    void swap(int& a, int& b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    void sortColors(vector<int>& nums) {
        if(nums.size() <= 1) {
            return;
        }
        int left = -1;
        int right = nums.size();
        for (int i = 0; i < right; ++i) {
            if (nums[i] < 1) {
                ++left;
                swap(nums[left], nums[i]);
            } else if(nums[i] > 1) {
                --right;
                swap(nums[right], nums[i]);
                --i;
            }
        }
    }
```

#### [排序链表](https://leetcode-cn.com/problems/sort-list/)

**思路**： 基本操作：cut + merge

```cpp
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode new_head(-1);
        ListNode* p = &new_head;
        while(l1 || l2) {
            int v1 = l1 ? l1->val : INT_MAX;
            int v2 = l2 ? l2->val : INT_MAX;
            if(v1 < v2) {
                ListNode* p1 = p->next;
                ListNode* p2 = l1->next;
                p->next = l1;
                l1->next = p1;
                l1 = p2;
            } else {
                ListNode* p1 = p->next;
                ListNode* p2 = l2->next;
                p->next = l2;
                l2->next = p1;
                l2 = p2;
            }
            p = p->next;
        }
        return new_head.next;
    }

    ListNode* cut(ListNode* head, int n) {
        int i = 0;
        while(head && i < n - 1) {
            head = head->next;
            ++i;
        }
        ListNode* ans = nullptr;
        if(head) {
            ans = head->next;
            head->next = nullptr;
        }
        return ans;
    }

    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) {
            return head;
        }
        ListNode new_head(-1);
        new_head.next = head;
        ListNode* p = &new_head;

        int len = 0;
        for(ListNode* p = head; p; p=p->next) {
             ++len;
        }

        for(int step = 1; step < len; step *= 2) {
            ListNode* p1 = new_head.next;
            new_head.next = nullptr;
            p = &new_head;
            ListNode* right = nullptr;
            while(p1) {
                ListNode* right = cut(p1, step);
                ListNode* left = p1;
                p1 = cut(right, step);
                p->next = merge(left, right);
                while(p && p->next) {
                    p = p->next;
                }
            }
        }
        return new_head.next;
    }
```
