
#### [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

`给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。`

**思路** ：双指针，加一个head在前面。一个指针先走n步，然后一起走到头。

```cpp
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if (!head) {
            return head;
        }
        ListNode new_head;
        new_head.next = head;
        ListNode* p1 = &new_head;
        ListNode* p2 = &new_head;
        int index = 0;
        while(p1 && index < n) {
            p1 = p1->next;
            ++index;
        }
        if(index != n) {
            return head;
        }
        while(p1 && p1->next) {
            p1 = p1->next;
            p2 = p2->next;
        }
        ListNode* tmp = p2->next;
        p2->next = p2->next->next;
        delete tmp;
        return new_head.next;
    }
```

#### [K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

`给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。`

**思路** ：双指针。

```cpp
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head || k <= 1) {
            return head;
        }
        ListNode new_head;
        new_head.next = head;

        ListNode* p1 = &new_head;
        ListNode* p2 = &new_head;
        int index = 0;
        int kindex = k;
        while(p1 && p2 && p1->next && p2->next) {
            while(p1 && p1->next && index != kindex) {
                p1 = p1->next;
                ++index;
            }
            if(index != kindex) {
                break;
            }
            ListNode* p3 = p2->next;
            ListNode* p2_next = p2->next;
            p1 = p1->next;
            while(p3 && p3 != p1) {
                ListNode* tmp = p2->next;
                p2->next = p3;
                ListNode* p3_next = p3->next;
                p3->next = tmp;
                p3 = p3_next;
            }
            p2 = p2_next;
            p2->next = p3;
            p1 = p2;
            kindex += k;
        }
        return new_head.next;
    }
```

#### [旋转链表](https://leetcode-cn.com/problems/rotate-list/)

`给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。`

**思路** ：k=k%len，一个指针向前走k步，两个再一起走到末尾。

```cpp
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || k <= 0) {
            return head;
        }
        int len = 0;
        ListNode* p = head;
        while(p) {
            ++len;
            p = p->next;
        }
        k = k % len;
        if(k == 0) {
            return head;
        }
        ListNode* p1 = head;
        ListNode* p2 = head;
        int index = 0;
        while(p1 && index < k) {
            p1 = p1->next;
            ++index;
        }
        while(p1 && p1->next) {
            p1 = p1->next;
            p2 = p2->next;
        }
        ListNode* ans = p2->next;
        p2->next = nullptr;
        p1->next = head;
        return ans;
    }
```

#### [链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

`给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。`

**思路** ：双指针，一快一慢

```cpp
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
```

#### [链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

`输入一个链表，输出该链表中倒数第k个节点。`

```cpp
    ListNode* getKthFromEnd(ListNode* head, int k) {
        if(!head || k < 1) {
            return head;
        }
        ListNode* p1 = head;
        ListNode* p2 = head;
        int index = 0;
        while(p2 && index < k - 1) {
            p2 = p2->next;
            ++index;
        }
        while(p2 && p2->next) {
            p1 = p1->next;
            p2 = p2->next;
        }
        return p1;
    }
```

#### [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

`合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。`

**思路** ：大小为k的堆。

```cpp
struct cmp {
    bool operator() (ListNode* left, ListNode* right){
        return left->val > right->val;
    }
};
std::priority_queue<ListNode*, vector<ListNode*>, cmp> pq;
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode res(-1);
    ListNode* p = &res;
    for (ListNode* i : lists) {
        if(i) {
            pq.push(i);
        }
    }
    while(!pq.empty()) {
        ListNode* v = pq.top();
        pq.pop();
        p->next = v;
        p = v;
        if(v->next) {
            pq.push(v->next);
        }
    }
    return res.next;
}
```

#### [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

`给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。`

```cpp
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next) {
            return head;
        }
        ListNode* p = head;
        while(p) {
            int v = p->val;
            while(p && p->next && p->next->val == v) {
                ListNode* tmp = p->next;
                p->next = p->next->next;
                delete tmp;
            }
            p = p->next;
        }
        return head;
    }
```

#### [删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

`给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。`

**思路** ：需要加个头节点。如果相邻节点重复，那么这个值对应的所有节点都删除。

```cpp
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next) {
            return head;
        }
        ListNode new_head(-1);
        new_head.next = head;
        ListNode* p = &new_head;
        while(p && p->next) {
            int v = p->next->val;
            ListNode* tmp = p->next->next;
            if(tmp && tmp->val == v) {
                while(p && p->next && p->next->val == v) {
                    ListNode* d = p->next;
                    p->next = p->next->next;
                    delete d;
                }
            } else {
                p = p->next;
            }
        }
        return new_head.next;
    }
```

#### [分隔链表](https://leetcode-cn.com/problems/partition-list/)

`给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。`

```cpp
    ListNode* partition(ListNode* head, int x) {
        if(!head || !head->next) {
            return head;
        }

        ListNode head_less(-1);
        ListNode* less = &head_less;

        ListNode head_more(-1);
        ListNode* more = &head_more;

        while(head) {
            if (head->val < x) {
                less->next = head;
                less = less->next;
            } else {
                more->next = head;
                more = more->next;
            }
            head = head->next;
        }
        less->next = head_more.next;
        more->next = nullptr;
        return head_less.next;
    }
```
