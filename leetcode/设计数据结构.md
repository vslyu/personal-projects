 
 #### [LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)
 
`获取数据 get 和 写入数据 put , 在 O(1) 时间复杂度内完成这两种操作` 
 
`获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。`
 
`写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。`
 
 ```cpp
class LRUCache {
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
    }
    
    int get(int key) {
        auto itr = m.find(key);
        if(itr == m.end()) {
            return -1;
        }
        auto pair = *(itr->second);
        q.erase(itr->second);
        m.erase(itr);
        q.push_front(pair);
        m[key] = q.begin();
        return pair.second;
    }
    
    void put(int key, int value) {
        auto itr = m.find(key);
        if(itr == m.end()) {
            if(m.size() == capacity) {
                auto pair = q.back();
                q.pop_back();
                m.erase(m.find(pair.first));
            }
            q.push_front(make_pair(key, value));
            m[key] = q.begin();
        } else {
            auto pair = *(itr->second);
            pair.second = value;
            q.erase(itr->second);
            q.push_front(pair);
            m[key] = q.begin();
        }
    }
    // <key, value>
    list<pair<int, int>> q;
    typedef list<pair<int, int>>::iterator iter;
    unordered_map<int, iter> m;
    int capacity;
};
 
 ```
 
 #### [最小栈](https://leetcode-cn.com/problems/min-stack/)
 
 `设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。`
 
 ```cpp
 class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
        cur_min.push(INT_MAX);
    }
    
    void push(int x) {
        st.push(x);
        if(cur_min.top() >= x) {
            cur_min.push(x);
        }
    }
    
    void pop() {
        int x = st.top();
        st.pop();
        if (x <= cur_min.top()) {
            cur_min.pop();
        }
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return cur_min.top();
    }
    
    stack<int> st;
    stack<int> cur_min;
};

 ```

#### [两数之和 III - 数据结构设计](https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/)

`设计并实现一个 TwoSum 的类，使该类需要支持 add 和 find 的操作。`

`add 操作 -  对内部数据结构增加一个数。`

`find 操作 - 寻找内部数据结构中是否存在一对整数，使得两数之和与给定的数相等。`

```cpp
class TwoSum {
public:
    /** Initialize your data structure here. */
    TwoSum() { }
    /** Add the number to an internal data structure.. */
    void add(int number) {
        m[number]++;
    }
    /** Find if there exists any pair of numbers which sum is equal to the value. */
    bool find(int value) {
        for(auto& kv : m) {
            int cur = value - kv.first;
            if(cur != kv.first && m.find(cur) != m.end()) {
                return true;
            } else if (cur == kv.first && m.find(cur) != m.end() && m[cur] > 1) {
                return true;
            }
        }
        return false;
    }
    unordered_map<int, int> m;
};

```
