
#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

`给定一个字符串 s，找到 s 中最长的回文子串.`

**思路**： p[i][j] = p[i+1][j-1] && s[i] == s[j]，从后往前遍历，可以把空间复杂度从n*n降低为n

```cpp
    string longestPalindrome(string s) {
        int len = s.length();
        if(len <= 1) {
            return s;
        }

        int m = 1;
        string ans = s.substr(0, 1);

        vector<bool> dp(len, false);
        dp[len - 1] = true;
        for(int i = len - 1; i >= 0; --i) {
            for(int j = len - 1; j >= i; --j) {
                if(i == j) {
                    dp[j] = true;
                } else if (i == j - 1) {
                    dp[j] = (s[i] == s[j]);
                } else {
                    dp[j] = dp[j - 1] && (s[i] == s[j]);
                }
                if (dp[j] && j - i + 1 > m) {
                    m = j - i + 1;
                    ans = s.substr(i, j - i + 1);
                }
            }
        }
        return ans;
    }
```

#### [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

`给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。`

**思路**：  以")"结尾，两个情况

 - ....() 就是 dp[i]=dp[i−2]+2
 - ....)) 并且s[i−dp[i−1]−1]=‘(’  就是 dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2

```cpp
    int longestValidParentheses(string s) {
        if (s.length() == 0) {
            return 0;
        }
        int len = s.length();
        vector<int> dp(len, 0);
        int max_value = 0;
        for(int i = 1; i < len; ++i) {
            if (s[i] == ')') {
                if(s[i - 1] == '(') {
                    dp[i] = 2;
                    if (i - 2>=0) {
                        dp[i] += dp[i-2];
                    }
                } else if (s[i - 1] == ')' && i - dp[i-1] - 1 >=0 &&
                           s[i - dp[i-1] - 1] == '(') {
                    dp[i] = dp[i - 1] + 2;
                    if (i - dp[i-1] - 2 >= 0) {
                        dp[i] += dp[i - dp[i-1] - 2];
                    }
                }
            }
            max_value = max(max_value, dp[i]);
        }
        return max_value;
    }
```

#### [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

`给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。`

**思路**： $$ f(i) = max\{ f(i−1)+ a_i, a_i \} $$
