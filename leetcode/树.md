#### [二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

`给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。返回到目标结点 target 距离为 K 的所有结点的值的列表。 
答案可以以任何顺序返回。`

**思路** ：如果这是个无向图／有向图，就直接bfs了，现在缺的只是子节点指向父节点的指针。两遍遍历，先用一个map记录子节点指向父节点，再bfs遍历一次即可。


#### [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

`给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。`

`百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”`

**思路** ：我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，
再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。

#### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**思路** ：背下来。
```cpp
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) {
            return ans;
        }
        stack<TreeNode*> st;
        TreeNode* p = root;
        while(!st.empty() || p) {
            while(p) {
                st.push(p);
                p = p->left;
            }
            TreeNode* r = st.top();
            st.pop();
            ans.push_back(r->val);
            p = r->right;
        }
        return ans;
    }
```

#### [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

**思路** ：后序是左-右-根，可以迭代的时候先按根-右-左，最后把输出数组反转一下。

#### [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

`给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？`

**思路** ： 动态规划题，

```cpp
// f[n] = f[0] * f[n-1] + f[1] * f[n-2] + ...+ f[n-1] * f[0];
// f[0] = 1  f[1] = 1
```

#### [不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

`给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。`

**思路** ：递归建树 vector<TreeNode*> recur(int start, int end) 分别以每个节点作为根节点。

#### [所有可能的满二叉树](https://leetcode-cn.com/problems/all-possible-full-binary-trees/)

`满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。答案中每个树的每个结点都必须有 node.val=0。你可以按任何顺序返回树的最终列表。`

**思路** ：跟上面的题类似。代码也几乎一样，区别是vector<TreeNode*> recur(int start, int end)返回的列表里没有nullptr。特殊情况是叶子节点，建立叶子节点后直接返回。

#### [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

`给定一个二叉树，判断其是否是一个有效的二叉搜索树。`

**思路** ：迭代中序遍历，维护一个pre指针指向前一个遍历的值，如果pre的值>=当前值，则返回false

#### [相同的树](https://leetcode-cn.com/problems/same-tree/)

`给定两个二叉树，编写一个函数来检验它们是否相同。`

**思路** ：两个指针一起递归

#### [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

`给定一个二叉树，检查它是否是镜像对称的。`

**思路** ：两个指针一起递归，只不过方向相反。

#### [翻转等价二叉树](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/)

`我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。编写一个判断两个二叉树是否是翻转等价的函数。`

**思路** ：都转到标准态遍历

#### [面试题 04.10. 检查子树](https://leetcode-cn.com/problems/check-subtree-lcci/)

`检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。`

**思路** ：递归遍历t1的每个节点，判断以t1中的每个节点为根的子树是否与t2相同

#### [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

**思路** ： 跟上题类似，但无需是子树，子结构即可。

#### [二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)

`给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。`

**思路** ： 跟上题类似，都是很暴力的解法

```cpp
    bool dfs(ListNode* head, TreeNode* root) {
        if(!head) {
            return true;
        } else if(!root) {
            return false;
        }
        return (head->val == root->val) && 
                (dfs(head->next, root->left) || dfs(head->next, root->right));
    }

    bool isSubPath(ListNode* head, TreeNode* root) {
        if(!head) {
            return true;
        } else if(!root) {
            return false;
        }
        return dfs(head, root) || isSubPath(head, root->left) 
            || isSubPath(head, root->right);
    }
```

#### [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

`给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。`

**思路** ： 队列做bfs，使用nullptr作为分界。

```cpp
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        vector<int> tmp;
        if(!root) {
            return ans;
        }
        queue<TreeNode*> st; 
        st.push(root);
        st.push(nullptr);
        while(!st.empty()) {
            TreeNode* t = st.front();
            st.pop();
            if (!t) {
                ans.push_back(tmp);
                tmp.clear();
                if(!st.empty()){
                    st.push(nullptr);
                    continue;
                }
                break;
            }
            tmp.push_back(t->val);
            if(t->left){
                st.push(t->left);
            }
            if(t->right){
                st.push(t->right);
            }
        }
        return ans;
    }
```

#### [填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

`填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL`

**思路** ： 同上，队列做bfs，在每层维护一个pre指针

#### [完全二叉树插入器](https://leetcode-cn.com/problems/complete-binary-tree-inserter/)

`完全二叉树是每一层（除最后一层外）都是完全填充（即，结点数达到最大）的，并且所有的结点都尽可能地集中在左侧。`

**思路** ：层次遍历，只不过是“拆开”。

